<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Logic Game: ƒêo√°n S·ªë Trung B√¨nh</title>
    <!-- T·∫£i Tailwind CSS ƒë·ªÉ l√†m ƒë·∫πp giao di·ªán -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* CSS t√πy ch·ªânh cho game */
      body {
        font-family: "Inter", sans-serif;
      }
      /* Th√™m font Inter */
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap");

      /* Hi·ªáu ·ª©ng m∆∞·ª£t m√† cho c√°c kh·ªëi */
      .game-state {
        transition: all 0.3s ease-in-out;
      }

      /* Style cho ng∆∞·ªùi ch∆°i b·ªã lo·∫°i */
      .player-card.eliminated {
        opacity: 0.4;
        filter: grayscale(100%);
        border-color: #ef4444; /* red-500 */
      }

      /* Style cho ng∆∞·ªùi ch∆°i th·∫Øng v√≤ng */
      .player-card.winner {
        border-color: #22c55e; /* green-500 */
        box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
      }

      /* Style cho ng∆∞·ªùi ch∆°i thua v√≤ng */
      .player-card.loser {
        border-color: #f97316; /* orange-500 */
      }

      /* T√πy ch·ªânh thanh tr∆∞·ª£t */
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 10px;
        background: #4b5563; /* gray-600 */
        border-radius: 5px;
        outline: none;
        opacity: 0.9;
        transition: opacity 0.2s;
      }
      input[type="range"]:hover {
        opacity: 1;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        background: #3b82f6; /* blue-500 */
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid white;
      }
      input[type="range"]::-moz-range-thumb {
        width: 25px;
        height: 25px;
        background: #3b82f6; /* blue-500 */
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid white;
      }
    </style>
  </head>
  <body
    class="bg-gray-900 text-white p-4 md:p-8 min-h-screen flex items-center justify-center"
  >
    <!-- Container ch√≠nh c·ªßa ·ª©ng d·ª•ng -->
    <div id="app" class="w-full max-w-5xl mx-auto">
      <!-- M√†n h√¨nh t·∫£i/x√°c th·ª±c -->
      <div id="auth-view" class="text-center">
        <h1 class="text-2xl font-bold mb-4">ƒêang k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß...</h1>
        <div
          class="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto"
        ></div>
        <p class="mt-4 text-sm text-gray-400">
          UserID c·ªßa b·∫°n:
          <span id="user-id-display" class="font-mono">...</span>
        </p>
      </div>

      <!-- M√†n h√¨nh ch·ªçn ph√≤ng -->
      <div
        id="room-view"
        class="hidden w-full max-w-md mx-auto bg-gray-800 p-6 rounded-lg shadow-xl"
      >
        <h1 class="text-3xl font-bold text-center mb-6">Game ƒêo√°n S·ªë</h1>
        <div class="mb-4">
          <label
            for="player-name"
            class="block text-sm font-medium text-gray-300 mb-2"
            >T√™n c·ªßa b·∫°n</label
          >
          <input
            type="text"
            id="player-name"
            class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n..."
          />
        </div>
        <button
          id="create-room-btn"
          class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-lg"
        >
          T·∫°o ph√≤ng m·ªõi
        </button>
        <div class="relative flex items-center justify-center my-6">
          <div class="absolute inset-0 flex items-center">
            <span class="w-full border-t border-gray-600"></span>
          </div>
          <span class="relative px-3 bg-gray-800 text-sm text-gray-400"
            >ho·∫∑c</span
          >
        </div>
        <div class="mb-4">
          <label
            for="room-id-input"
            class="block text-sm font-medium text-gray-300 mb-2"
            >ID Ph√≤ng</label
          >
          <input
            type="text"
            id="room-id-input"
            class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Nh·∫≠p ID ph√≤ng ƒë·ªÉ tham gia..."
          />
        </div>
        <button
          id="join-room-btn"
          class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-lg"
        >
          Tham gia ph√≤ng
        </button>
      </div>

      <!-- M√†n h√¨nh Game ch√≠nh -->
      <div id="game-view" class="hidden w-full">
        <!-- Header th√¥ng tin ph√≤ng -->
        <div
          id="game-header"
          class="mb-4 p-4 bg-gray-800 rounded-lg shadow-md flex flex-col md:flex-row justify-between items-center gap-2"
        >
          <div>
            <span class="text-gray-400">Room ID:</span>
            <strong
              id="room-id-display"
              class="text-lg font-bold text-yellow-400 cursor-pointer"
              title="Nh·∫•n ƒë·ªÉ copy"
              >...</strong
            >
          </div>
          <div class="text-gray-400">
            V√≤ng:
            <strong id="round-display" class="text-lg text-white">0</strong>
          </div>
          <div>
            <span class="text-gray-400">Your UserID:</span>
            <strong
              id="game-user-id-display"
              class="text-sm font-mono text-gray-300"
              >...</strong
            >
          </div>
        </div>

        <!-- Danh s√°ch ng∆∞·ªùi ch∆°i -->
        <div
          id="player-list"
          class="mb-6 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"
        >
          <!-- Th·∫ª ng∆∞·ªùi ch∆°i s·∫Ω ƒë∆∞·ª£c th√™m b·∫±ng JS -->
        </div>

        <!-- C√°c tr·∫°ng th√°i c·ªßa Game -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl">
          <!-- Tr·∫°ng th√°i: Ph√≤ng ch·ªù (Lobby) -->
          <div id="lobby-state" class="game-state hidden text-center">
            <h2 class="text-2xl font-bold mb-4">ƒêang ch·ªù ng∆∞·ªùi ch∆°i...</h2>
            <p class="text-gray-400 mb-6">
              C·∫ßn √≠t nh·∫•t 3 ng∆∞·ªùi ch∆°i s·∫µn s√†ng ƒë·ªÉ b·∫Øt ƒë·∫ßu.
            </p>
            <button
              id="ready-btn"
              class="w-full max-w-xs mx-auto bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 shadow-lg"
            >
              S·∫µn s√†ng
            </button>
          </div>

          <!-- Tr·∫°ng th√°i: ƒêang ch∆°i (Playing) -->
          <div id="playing-state" class="game-state hidden">
            <div
              class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4"
            >
              <h2 class="text-2xl font-bold text-center md:text-left">
                V√≤ng <span id="playing-round-display"></span>: Ch·ªçn m·ªôt s·ªë!
              </h2>
              <div class="text-6xl font-black text-red-500" id="timer-display">
                60
              </div>
            </div>

            <div class="max-w-lg mx-auto">
              <div class="flex justify-between items-center mb-2">
                <label for="number-slider" class="text-lg font-medium"
                  >Ch·ªçn s·ªë (1-100)</label
                >
                <span
                  id="slider-value"
                  class="text-3xl font-bold text-blue-400 bg-gray-700 px-4 py-1 rounded-lg"
                  >50</span
                >
              </div>
              <input
                type="range"
                id="number-slider"
                min="1"
                max="100"
                value="50"
                class="w-full mb-6"
              />

              <button
                id="submit-number-btn"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 shadow-lg"
              >
                Ch·ªët s·ªë!
              </button>
            </div>

            <div id="waiting-for-others" class="hidden text-center mt-8">
              <p class="text-xl text-gray-400">
                ƒê√£ ch·ªët s·ªë! ƒêang ch·ªù ng∆∞·ªùi kh√°c...
              </p>
              <div
                class="w-12 h-12 border-4 border-blue-400 border-t-transparent rounded-full animate-spin mx-auto mt-4"
              ></div>
            </div>
          </div>

          <!-- Tr·∫°ng th√°i: K·∫øt th√∫c v√≤ng (Round End) -->
          <div id="round-end-state" class="game-state hidden text-center">
            <h2 class="text-3xl font-bold mb-4">
              K·∫øt qu·∫£ V√≤ng <span id="round-end-round-display"></span>
            </h2>
            <p class="text-xl text-gray-300 mb-6">
              S·ªë trung b√¨nh l√†:
              <strong
                id="average-display"
                class="text-4xl font-bold text-yellow-400 mx-2"
                >0.00</strong
              >
            </p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
              <div class="bg-gray-700 p-4 rounded-lg">
                <h3 class="text-xl font-semibold text-green-400 mb-3">
                  Th·∫Øng v√≤ng (+1 ƒëi·ªÉm)
                </h3>
                <ul id="winners-list" class="list-disc list-inside text-left">
                  <!-- JS th√™m ng∆∞·ªùi th·∫Øng -->
                </ul>
              </div>
              <div class="bg-gray-700 p-4 rounded-lg">
                <h3 class="text-xl font-semibold text-red-400 mb-3">
                  Thua v√≤ng
                </h3>
                <ul id="losers-list" class="list-disc list-inside text-left">
                  <!-- JS th√™m ng∆∞·ªùi thua -->
                </ul>
              </div>
            </div>

            <button
              id="next-round-btn"
              class="hidden w-full max-w-xs mx-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 shadow-lg"
            >
              B·∫Øt ƒë·∫ßu v√≤ng ti·∫øp theo
            </button>
            <p id="waiting-for-host" class="text-gray-400">
              Ch·ªù ch·ªß ph√≤ng b·∫Øt ƒë·∫ßu v√≤ng ti·∫øp theo...
            </p>
          </div>

          <!-- Tr·∫°ng th√°i: K·∫øt th√∫c Game (Game End) -->
          <div id="game-end-state" class="game-state hidden text-center">
            <h2 class="text-4xl font-bold mb-8">Game K·∫øt Th√∫c!</h2>

            <h3 class="text-2xl font-semibold mb-4">B·∫£ng X·∫øp H·∫°ng</h3>
            <div id="rankings" class="space-y-3 max-w-md mx-auto">
              <!-- 
                        <div class="flex justify-between items-center bg-gray-700 p-4 rounded-lg text-lg">
                            <span class="font-bold text-yellow-300">ü•á 1. Player Name</span>
                            <span class="font-bold">20 ƒëi·ªÉm</span>
                        </div>
                        -->
            </div>

            <button
              id="reset-game-btn"
              class="hidden w-full max-w-xs mx-auto mt-8 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-200 shadow-lg"
            >
              Ch∆°i l·∫°i
            </button>
            <p id="waiting-for-reset" class="text-gray-400 mt-4">
              Ch·ªù ch·ªß ph√≤ng ch∆°i l·∫°i...
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Overlay t·∫£i -->
    <div
      id="loading-overlay"
      class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
    >
      <div
        class="w-16 h-16 border-4 border-white border-t-transparent rounded-full animate-spin"
      ></div>
    </div>

    <!-- H·ªôp th√¥ng b√°o t√πy ch·ªânh -->
    <div
      id="message-box"
      class="hidden fixed top-5 right-5 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-xl z-50 transition-all duration-300 transform translate-x-full"
    >
      <span id="message-text"></span>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
      // Import c√°c module c·∫ßn thi·∫øt t·ª´ Firebase
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        signInWithCustomToken,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        updateDoc,
        onSnapshot,
        Timestamp,
        writeBatch,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      // --- BI·∫æN TO√ÄN C·ª§C ---
      let app, db, auth;
      let userId = null; // ID ng∆∞·ªùi d√πng sau khi x√°c th·ª±c
      let currentRoomId = null; // ID ph√≤ng hi·ªán t·∫°i
      let unsubscribeRoom = null; // H√†m ƒë·ªÉ h·ªßy l·∫Øng nghe snapshot
      let hostTimer = null; // Timer c·ªßa ch·ªß ph√≤ng ƒë·ªÉ t√≠nh to√°n
      let uiTimerInterval = null; // Timer c·ªßa UI ƒë·ªÉ ƒë·∫øm ng∆∞·ª£c
      let isHost = false; // Ng∆∞·ªùi ch∆°i n√†y c√≥ ph·∫£i ch·ªß ph√≤ng kh√¥ng

      // --- BI·∫æN C·∫§U H√åNH (ƒê√£ nh√∫ng tƒ©nh) ---
      // 'appId' n√†y d√πng ƒë·ªÉ ph√¢n t√°ch d·ªØ li·ªáu trong Firestore
      const appId = "near-the-mean-game"; // ƒê·ªïi t√™n ƒë·ªÉ kh·ªõp v·ªõi d·ª± √°n c·ªßa b·∫°n

      // C·∫•u h√¨nh Firebase do ng∆∞·ªùi d√πng cung c·∫•p
      const firebaseConfig = {
        apiKey: "AIzaSyAtk6aeWYBNKrBasdUkxVx6tIvy4Xe7jA8",
        authDomain: "near-the-mean.firebaseapp.com",
        projectId: "near-the-mean",
        storageBucket: "near-the-mean.firebasestorage.app", // S·ª≠a l·ªói c√∫ ph√°p 'firebasestorage'
        messagingSenderId: "204542056653",
        appId: "1:204542056653:web:ad8e3c574dc24c3eb7b184",
        measurementId: "G-H6E91RRXXK",
      };

      // B·ªè qua custom token, ch·ªâ d√πng ƒëƒÉng nh·∫≠p ·∫©n danh
      const initialAuthToken = null;

      // --- C√ÅC ƒê·ªêI T∆Ø·ª¢NG DOM ---
      const authView = document.getElementById("auth-view");
      const roomView = document.getElementById("room-view");
      const gameView = document.getElementById("game-view");
      const loadingOverlay = document.getElementById("loading-overlay");
      const userIdDisplay = document.getElementById("user-id-display");

      const playerNameInput = document.getElementById("player-name");
      const roomIdInput = document.getElementById("room-id-input");
      const createRoomBtn = document.getElementById("create-room-btn");
      const joinRoomBtn = document.getElementById("join-room-btn");

      const roomIdDisplay = document.getElementById("room-id-display");
      const gameUserIdDisplay = document.getElementById("game-user-id-display");
      const roundDisplay = document.getElementById("round-display");
      const playerList = document.getElementById("player-list");

      const lobbyState = document.getElementById("lobby-state");
      const readyBtn = document.getElementById("ready-btn");

      const playingState = document.getElementById("playing-state");
      const playingRoundDisplay = document.getElementById(
        "playing-round-display"
      );
      const timerDisplay = document.getElementById("timer-display");
      const numberSlider = document.getElementById("number-slider");
      const sliderValue = document.getElementById("slider-value");
      const submitNumberBtn = document.getElementById("submit-number-btn");
      const waitingForOthers = document.getElementById("waiting-for-others");

      const roundEndState = document.getElementById("round-end-state");
      const roundEndRoundDisplay = document.getElementById(
        "round-end-round-display"
      );
      const averageDisplay = document.getElementById("average-display");
      const winnersList = document.getElementById("winners-list");
      const losersList = document.getElementById("losers-list");
      const nextRoundBtn = document.getElementById("next-round-btn");
      const waitingForHost = document.getElementById("waiting-for-host");

      const gameEndState = document.getElementById("game-end-state");
      const rankings = document.getElementById("rankings");
      const resetGameBtn = document.getElementById("reset-game-btn");
      const waitingForReset = document.getElementById("waiting-for-reset");

      // --- H√ÄM TI·ªÜN √çCH ---

      /**
       * Hi·ªÉn th·ªã th√¥ng b√°o t√πy ch·ªânh thay v√¨ alert()
       * @param {string} message - N·ªôi dung th√¥ng b√°o
       * @param {boolean} isError - C√≥ ph·∫£i l√† l·ªói kh√¥ng (ƒë·ªïi m√†u)
       */
      function showMessage(message, isError = false) {
        const msgBox = document.getElementById("message-box");
        const msgText = document.getElementById("message-text");

        msgText.textContent = message;
        msgBox.classList.remove(
          "hidden",
          "translate-x-full",
          "bg-blue-500",
          "bg-red-500"
        );

        if (isError) {
          msgBox.classList.add("bg-red-500");
        } else {
          msgBox.classList.add("bg-blue-500");
        }

        // Hi·ªán
        msgBox.classList.remove("translate-x-full");

        // ·∫®n sau 3 gi√¢y
        setTimeout(() => {
          msgBox.classList.add("translate-x-full");
        }, 3000);
      }

      /**
       * T·∫°o ID ph√≤ng ng·∫´u nhi√™n
       * @param {number} length - ƒê·ªô d√†i ID
       */
      function createRoomId(length = 6) {
        return Math.random()
          .toString(36)
          .substring(2, 2 + length)
          .toUpperCase();
      }

      /**
       * Hi·ªÉn th·ªã/·∫®n overlay t·∫£i
       * @param {boolean} show - Hi·ªÉn th·ªã hay ·∫©n
       */
      function showLoading(show) {
        loadingOverlay.classList.toggle("hidden", !show);
      }

      /**
       * Chuy·ªÉn ƒë·ªïi gi·ªØa c√°c m√†n h√¨nh ch√≠nh
       * @param {string} viewName - 'auth', 'room', 'game'
       */
      function switchView(viewName) {
        authView.classList.add("hidden");
        roomView.classList.add("hidden");
        gameView.classList.add("hidden");

        if (viewName === "auth") authView.classList.remove("hidden");
        if (viewName === "room") roomView.classList.remove("hidden");
        if (viewName === "game") gameView.classList.remove("hidden");
      }

      /**
       * L·∫•y ƒë∆∞·ªùng d·∫´n document c·ªßa ph√≤ng
       * @param {string} rId - Room ID
       */
      function getRoomRef(rId) {
        // S·ª≠ d·ª•ng appId ƒë√£ ƒë·ªãnh nghƒ©a ·ªü tr√™n
        return doc(
          db,
          "artifacts",
          appId,
          "public",
          "data",
          "average-game-rooms",
          rId
        );
      }

      // --- KH·ªûI T·∫†O FIREBASE ---

      async function initFirebase() {
        try {
          // Ki·ªÉm tra n·∫øu firebaseConfig r·ªóng (tr∆∞·ªùng h·ª£p ng∆∞·ªùi d√πng d√°n sai)
          if (!firebaseConfig.apiKey) {
            showMessage("L·ªói c·∫•u h√¨nh Firebase. Kh√¥ng th·ªÉ kh·ªüi t·∫°o.", true);
            console.error("L·ªói: firebaseConfig r·ªóng ho·∫∑c kh√¥ng h·ª£p l·ªá.");
            authView.innerHTML =
              '<h1 class="text-2xl font-bold mb-4 text-red-500">L·ªói C·∫•u h√¨nh Firebase</h1><p>Vui l√≤ng ki·ªÉm tra l·∫°i firebaseConfig trong file index.html.</p>';
            return;
          }

          app = initializeApp(firebaseConfig);
          db = getFirestore(app);
          auth = getAuth(app);

          // L·∫Øng nghe thay ƒë·ªïi tr·∫°ng th√°i x√°c th·ª±c
          onAuthStateChanged(auth, (user) => {
            if (user) {
              console.log("User is signed in:", user.uid);
              userId = user.uid;
              userIdDisplay.textContent = userId;
              gameUserIdDisplay.textContent = userId;
              switchView("room"); // Chuy·ªÉn ƒë·∫øn m√†n h√¨nh ch·ªçn ph√≤ng
            } else {
              console.log("User is signed out.");
              userId = null;
              switchView("auth");
              signIn(); // T·ª± ƒë·ªông ƒëƒÉng nh·∫≠p n·∫øu ch∆∞a
            }
          });
        } catch (error) {
          console.error("L·ªói kh·ªüi t·∫°o Firebase:", error);
          showMessage("Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß. Vui l√≤ng t·∫£i l·∫°i.", true);
          authView.innerHTML = `<h1 class="text-2xl font-bold mb-4 text-red-500">L·ªói Kh·ªüi t·∫°o Firebase</h1><p class="text-gray-400">${error.message}</p>`;
        }
      }

      /**
       * ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng (ƒê√£ ƒë∆°n gi·∫£n h√≥a)
       */
      async function signIn() {
        try {
          // Ch·ªâ s·ª≠ d·ª•ng ƒëƒÉng nh·∫≠p ·∫©n danh
          console.log("Signing in anonymously...");
          await signInAnonymously(auth);
        } catch (error) {
          console.error("L·ªói ƒëƒÉng nh·∫≠p:", error);
          showMessage("L·ªói ƒëƒÉng nh·∫≠p. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi.", true);
        }
      }

      // --- LOGIC PH√íNG V√Ä LOBBY ---

      /**
       * X·ª≠ l√Ω t·∫°o ph√≤ng
       */
      async function handleCreateRoom() {
        const playerName = playerNameInput.value.trim();
        if (!playerName) {
          showMessage("Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!", true);
          return;
        }

        showLoading(true);
        const newRoomId = createRoomId();
        const roomRef = getRoomRef(newRoomId);

        const newPlayer = {
          name: playerName,
          score: 5,
          isReady: false,
          isEliminated: false,
          currentChoice: null,
          submittedThisRound: false,
        };

        const roomData = {
          roomId: newRoomId,
          hostId: userId,
          gameState: "lobby", // "lobby", "playing", "roundEnd", "gameEnd"
          round: 0,
          roundDeadline: null,
          roundAverage: null,
          roundWinners: [],
          roundLosers: {},
          initialPlayerCount: 1,
          players: {
            [userId]: newPlayer,
          },
          createdAt: Timestamp.now(),
        };

        try {
          await setDoc(roomRef, roomData);
          await joinRoom(newRoomId, playerName);
        } catch (error) {
          console.error("L·ªói t·∫°o ph√≤ng:", error);
          showMessage("L·ªói t·∫°o ph√≤ng. Vui l√≤ng th·ª≠ l·∫°i.", true);
        } finally {
          showLoading(false);
        }
      }

      /**
       * X·ª≠ l√Ω tham gia ph√≤ng
       */
      async function handleJoinRoom() {
        const playerName = playerNameInput.value.trim();
        if (!playerName) {
          showMessage("Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!", true);
          return;
        }

        const rId = roomIdInput.value.trim().toUpperCase();
        if (!rId) {
          showMessage("Vui l√≤ng nh·∫≠p ID ph√≤ng!", true);
          return;
        }

        showLoading(true);
        const roomRef = getRoomRef(rId);

        try {
          const roomSnap = await getDoc(roomRef);
          if (!roomSnap.exists()) {
            showMessage("Ph√≤ng kh√¥ng t·ªìn t·∫°i!", true);
            return;
          }

          const roomData = roomSnap.data();

          // Kh√¥ng cho tham gia n·∫øu game ƒë√£ b·∫Øt ƒë·∫ßu
          if (roomData.gameState !== "lobby") {
            showMessage("Game ƒë√£ b·∫Øt ƒë·∫ßu, kh√¥ng th·ªÉ tham gia!", true);
            return;
          }

          // Kh√¥ng cho tham gia n·∫øu qu√° 10 ng∆∞·ªùi
          if (Object.keys(roomData.players).length >= 10) {
            showMessage("Ph√≤ng ƒë√£ ƒë·∫ßy (t·ªëi ƒëa 10 ng∆∞·ªùi)!", true);
            return;
          }

          // Th√™m ng∆∞·ªùi ch∆°i m·ªõi
          const newPlayer = {
            name: playerName,
            score: 5,
            isReady: false,
            isEliminated: false,
            currentChoice: null,
            submittedThisRound: false,
          };

          await updateDoc(roomRef, {
            [`players.${userId}`]: newPlayer,
          });

          await joinRoom(rId, playerName);
        } catch (error) {
          console.error("L·ªói tham gia ph√≤ng:", error);
          showMessage("L·ªói tham gia ph√≤ng. Vui l√≤ng th·ª≠ l·∫°i.", true);
        } finally {
          showLoading(false);
        }
      }

      /**
       * Thi·∫øt l·∫≠p l·∫Øng nghe khi v√†o ph√≤ng
       * @param {string} rId - Room ID
       */
      function joinRoom(rId, playerName) {
        currentRoomId = rId;
        const roomRef = getRoomRef(rId);

        // L∆∞u t√™n v√†o localStorage ƒë·ªÉ kh√¥ng ph·∫£i nh·∫≠p l·∫°i
        localStorage.setItem("playerName", playerName);

        // H·ªßy l·∫Øng nghe c≈© (n·∫øu c√≥)
        if (unsubscribeRoom) {
          unsubscribeRoom();
        }

        // L·∫Øng nghe thay ƒë·ªïi c·ªßa ph√≤ng
        unsubscribeRoom = onSnapshot(
          roomRef,
          (docSnap) => {
            if (!docSnap.exists()) {
              // Ph√≤ng ƒë√£ b·ªã x√≥a (VD: ch·ªß ph√≤ng r·ªùi)
              showMessage("Ph√≤ng kh√¥ng c√≤n t·ªìn t·∫°i.", true);
              leaveRoom();
              return;
            }
            const roomData = docSnap.data();
            window.currentRoomData = roomData; // L∆∞u snapshot m·ªõi nh·∫•t v√†o global
            renderGame(roomData); // H√†m render ch√≠nh

            // Logic t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu game c·ªßa CH·ª¶ PH√íNG
            if (isHost && roomData.gameState === "lobby") {
              checkAutoStart(roomData);
            }

            // Logic t√≠nh to√°n c·ªßa CH·ª¶ PH√íNG
            if (isHost && roomData.gameState === "playing") {
              checkAllSubmitted(roomData);
            }
          },
          (error) => {
            console.error("L·ªói l·∫Øng nghe ph√≤ng:", error);
            showMessage("M·∫•t k·∫øt n·ªëi v·ªõi ph√≤ng.", true);
            leaveRoom();
          }
        );

        switchView("game");
      }

      /**
       * R·ªùi ph√≤ng (quay v·ªÅ m√†n h√¨nh ch√≠nh)
       */
      function leaveRoom() {
        if (unsubscribeRoom) {
          unsubscribeRoom();
          unsubscribeRoom = null;
        }
        currentRoomId = null;
        isHost = false;
        window.currentRoomData = null;
        if (hostTimer) clearTimeout(hostTimer);
        if (uiTimerInterval) clearInterval(uiTimerInterval);
        switchView("room");
      }

      /**
       * X·ª≠ l√Ω s·∫µn s√†ng
       */
      async function handleReady() {
        if (!currentRoomId || !userId) return;
        readyBtn.disabled = true;
        readyBtn.textContent = "ƒêang x·ª≠ l√Ω...";

        const roomRef = getRoomRef(currentRoomId);
        try {
          // L·∫•y tr·∫°ng th√°i s·∫µn s√†ng hi·ªán t·∫°i
          const roomSnap = await getDoc(roomRef);
          const currentReadyState = roomSnap.data().players[userId].isReady;

          await updateDoc(roomRef, {
            [`players.${userId}.isReady`]: !currentReadyState,
          });
          // N√∫t s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t qua onSnapshot
        } catch (error) {
          console.error("L·ªói c·∫≠p nh·∫≠t s·∫µn s√†ng:", error);
          showMessage("C√≥ l·ªói, th·ª≠ l·∫°i sau.", true);
          readyBtn.disabled = false;
        }
      }

      /**
       * (CH·ª¶ PH√íNG) Ki·ªÉm tra ƒëi·ªÅu ki·ªán t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu
       */
      function checkAutoStart(roomData) {
        const players = Object.values(roomData.players);
        const activePlayers = players.filter((p) => !p.isEliminated);

        if (activePlayers.length < 3) return; // Ch∆∞a ƒë·ªß 3 ng∆∞·ªùi

        const allReady = activePlayers.every((p) => p.isReady);
        if (allReady) {
          console.log("T·∫•t c·∫£ ƒë√£ s·∫µn s√†ng! B·∫Øt ƒë·∫ßu game...");
          startGame(roomData);
        }
      }

      // --- LOGIC CH√çNH C·ª¶A GAME ---

      /**
       * (CH·ª¶ PH√íNG) B·∫Øt ƒë·∫ßu game (ho·∫∑c v√≤ng m·ªõi)
       */
      async function startGame(roomData) {
        // D·ªçn d·∫πp timer c≈©
        if (hostTimer) clearTimeout(hostTimer);

        showLoading(true);
        const roomRef = getRoomRef(currentRoomId);
        const deadline = Timestamp.fromDate(new Date(Date.now() + 60000)); // 60 gi√¢y

        // Reset tr·∫°ng th√°i v√≤ng m·ªõi cho ng∆∞·ªùi ch∆°i
        const updatedPlayers = { ...roomData.players };
        let activePlayerCount = 0;
        Object.keys(updatedPlayers).forEach((pid) => {
          if (!updatedPlayers[pid].isEliminated) {
            updatedPlayers[pid].currentChoice = null;
            updatedPlayers[pid].submittedThisRound = false;
            activePlayerCount++;
          }
          // Reset isReady sau khi game b·∫Øt ƒë·∫ßu
          updatedPlayers[pid].isReady = false;
        });

        // N·∫øu l√† v√≤ng ƒë·∫ßu ti√™n, l∆∞u s·ªë ng∆∞·ªùi ch∆°i ban ƒë·∫ßu
        const isFirstRound = roomData.round === 0;

        try {
          await updateDoc(roomRef, {
            gameState: "playing",
            round: roomData.round + 1,
            roundDeadline: deadline,
            players: updatedPlayers,
            // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu l√† v√≤ng 1
            ...(isFirstRound && { initialPlayerCount: activePlayerCount }),
          });

          // Ch·ªß ph√≤ng ƒë·∫∑t timer 60s ƒë·ªÉ t·ª± ƒë·ªông t√≠nh to√°n
          hostTimer = setTimeout(calculateResults, 60000);
        } catch (error) {
          console.error("L·ªói b·∫Øt ƒë·∫ßu game:", error);
        } finally {
          showLoading(false);
        }
      }

      /**
       * (CH·ª¶ PH√íNG) Ki·ªÉm tra xem t·∫•t c·∫£ ƒë√£ n·ªôp ch∆∞a
       */
      function checkAllSubmitted(roomData) {
        if (!roomData || !roomData.players) return;

        const activePlayers = Object.values(roomData.players).filter(
          (p) => !p.isEliminated
        );
        const allSubmitted = activePlayers.every((p) => p.submittedThisRound);

        if (allSubmitted && activePlayers.length > 0) {
          console.log("T·∫•t c·∫£ ƒë√£ n·ªôp, t√≠nh to√°n ngay...");
          if (hostTimer) clearTimeout(hostTimer);
          calculateResults();
        }
      }

      /**
       * X·ª≠ l√Ω n·ªôp s·ªë
       */
      async function handleSubmitNumber() {
        const number = parseInt(numberSlider.value, 10);
        if (isNaN(number) || number < 1 || number > 100) {
          showMessage("S·ªë kh√¥ng h·ª£p l·ªá!", true);
          return;
        }

        submitNumberBtn.disabled = true;
        waitingForOthers.classList.remove("hidden");

        const roomRef = getRoomRef(currentRoomId);
        try {
          await updateDoc(roomRef, {
            [`players.${userId}.currentChoice`]: number,
            [`players.${userId}.submittedThisRound`]: true,
          });
        } catch (error) {
          console.error("L·ªói n·ªôp s·ªë:", error);
          showMessage("L·ªói n·ªôp s·ªë, th·ª≠ l·∫°i!", true);
          submitNumberBtn.disabled = false;
          waitingForOthers.classList.add("hidden");
        }
      }

      /**
       * (CH·ª¶ PH√íNG) T√≠nh to√°n k·∫øt qu·∫£ v√≤ng
       */
      async function calculateResults() {
        // D·ªçn d·∫πp timer
        if (hostTimer) clearTimeout(hostTimer);
        hostTimer = null;

        console.log("ƒêang t√≠nh to√°n k·∫øt qu·∫£...");
        const roomRef = getRoomRef(currentRoomId);

        try {
          // S·ª≠ d·ª•ng batch write ƒë·ªÉ c·∫≠p nh·∫≠t 1 l·∫ßn
          const batch = writeBatch(db);

          // L·∫•y d·ªØ li·ªáu M·ªöI NH·∫§T
          const roomSnap = await getDoc(roomRef);
          if (!roomSnap.exists()) return;
          const roomData = roomSnap.data();

          // Tr√°nh t√≠nh to√°n 2 l·∫ßn
          if (roomData.gameState !== "playing") {
            console.log("Tr·∫°ng th√°i kh√¥ng ph·∫£i 'playing', b·ªè qua t√≠nh to√°n.");
            return;
          }

          const players = roomData.players;
          const updatedPlayers = JSON.parse(JSON.stringify(players)); // Deep copy
          const submissions = [];
          let totalEliminated = 0;

          // 1. X·ª≠ l√Ω timeout v√† ƒë·∫øm ng∆∞·ªùi b·ªã lo·∫°i
          Object.entries(updatedPlayers).forEach(([pid, player]) => {
            if (player.isEliminated) {
              totalEliminated++;
              return; // B·ªè qua n·∫øu ƒë√£ b·ªã lo·∫°i t·ª´ tr∆∞·ªõc
            }

            // N·∫øu kh√¥ng n·ªôp b√†i v√† game c√≤n ƒëang ch∆°i
            if (!player.submittedThisRound) {
              console.log(
                `Ng∆∞·ªùi ch∆°i ${player.name} (${pid}) b·ªã lo·∫°i do timeout.`
              );
              player.isEliminated = true;
              player.score = -10; // ƒê·∫£m b·∫£o b·ªã lo·∫°i
              totalEliminated++;
            } else {
              // Th√™m v√†o danh s√°ch n·ªôp b√†i h·ª£p l·ªá
              submissions.push({
                id: pid,
                choice: player.currentChoice,
              });
            }
          });

          // L·∫•y s·ªë ng∆∞·ªùi ch∆°i ban ƒë·∫ßu
          const initialPlayerCount =
            roomData.initialPlayerCount || Object.keys(players).length;
          let activeSubmitters = submissions.length;
          let average = 0;
          let winners = [];
          let losers = {};
          let roundPenalty = -1;

          // 2. T√≠nh to√°n h√¨nh ph·∫°t
          const eliminatedPercentage = totalEliminated / initialPlayerCount;
          if (eliminatedPercentage >= 0.5) {
            roundPenalty = -2;
          }

          let nextGameState = "roundEnd";

          // 3. T√≠nh to√°n n·∫øu c√≥ ng∆∞·ªùi n·ªôp b√†i
          if (activeSubmitters > 0) {
            // 3.1. T√≠nh trung b√¨nh
            const sum = submissions.reduce((acc, s) => acc + s.choice, 0);
            average = sum / activeSubmitters;

            // 3.2. T√≠nh kho·∫£ng c√°ch
            const distances = submissions.map((s) => ({
              id: s.id,
              dist: Math.abs(s.choice - average),
            }));
            distances.sort((a, b) => a.dist - b.dist);

            // 3.3. X√°c ƒë·ªãnh ng∆∞·ªùi th·∫Øng (25%)
            // Lu√¥n c√≥ √≠t nh·∫•t 1 ng∆∞·ªùi th·∫Øng
            const winnerCount = Math.max(1, Math.ceil(activeSubmitters * 0.25));
            // L·∫•y kho·∫£ng c√°ch c·ªßa ng∆∞·ªùi th·ª© N
            const winningDistance = distances[winnerCount - 1].dist;

            // X·ª≠ l√Ω logic "ch√¢m ch∆∞·ªõc" (tr√πng s·ªë)
            // T·∫•t c·∫£ nh·ªØng ai c√≥ kho·∫£ng c√°ch <= winningDistance ƒë·ªÅu th·∫Øng
            winners = distances
              .filter((d) => d.dist <= winningDistance)
              .map((d) => d.id);

            // 3.4. C·∫≠p nh·∫≠t ƒëi·ªÉm
            submissions.forEach((sub) => {
              const pid = sub.id;
              if (winners.includes(pid)) {
                // Th·∫Øng
                updatedPlayers[pid].score += 1;
              } else {
                // Thua
                updatedPlayers[pid].score += roundPenalty;
                losers[pid] = roundPenalty;
              }
            });
          } else {
            // Kh√¥ng ai n·ªôp b√†i
            average = 0;
          }

          // 4. Ki·ªÉm tra lo·∫°i ng∆∞·ªùi ch∆°i do ƒëi·ªÉm th·∫•p v√† ƒë·∫øm ng∆∞·ªùi c√≤n l·∫°i
          let activePlayersAfterRound = 0;
          Object.keys(updatedPlayers).forEach((pid) => {
            if (!updatedPlayers[pid].isEliminated) {
              if (updatedPlayers[pid].score <= -5) {
                updatedPlayers[pid].isEliminated = true;
                console.log(
                  `Ng∆∞·ªùi ch∆°i ${updatedPlayers[pid].name} (${pid}) b·ªã lo·∫°i do ƒëi·ªÉm <= -5.`
                );
              } else {
                activePlayersAfterRound++;
              }
            }
          });

          // 5. Ki·ªÉm tra k·∫øt th√∫c game
          if (activePlayersAfterRound <= 1) {
            nextGameState = "gameEnd";
            console.log("Game k·∫øt th√∫c!");
          }

          // 6. C·∫≠p nh·∫≠t v√†o batch
          batch.update(roomRef, {
            gameState: nextGameState,
            players: updatedPlayers,
            roundAverage: average,
            roundWinners: winners,
            roundLosers: losers,
          });

          await batch.commit();
        } catch (error) {
          console.error("L·ªói nghi√™m tr·ªçng khi t√≠nh to√°n k·∫øt qu·∫£:", error);
          // Th·ª≠ reset v·ªÅ lobby n·∫øu c√≥ l·ªói
          await updateDoc(roomRef, { gameState: "lobby" });
        }
      }

      /**
       * (CH·ª¶ PH√íNG) Reset game v·ªÅ lobby
       */
      async function handleResetGame() {
        if (!isHost) return;

        showLoading(true);
        const roomRef = getRoomRef(currentRoomId);

        try {
          // L·∫•y d·ªØ li·ªáu ng∆∞·ªùi ch∆°i hi·ªán t·∫°i
          const roomSnap = await getDoc(roomRef);
          const players = roomSnap.data().players;

          // Reset t·∫•t c·∫£ ng∆∞·ªùi ch∆°i
          const updatedPlayers = {};
          Object.keys(players).forEach((pid) => {
            updatedPlayers[pid] = {
              ...players[pid],
              score: 5,
              isReady: false,
              isEliminated: false,
              currentChoice: null,
              submittedThisRound: false,
            };
          });

          await updateDoc(roomRef, {
            gameState: "lobby",
            round: 0,
            roundDeadline: null,
            roundAverage: null,
            roundWinners: [],
            roundLosers: {},
            initialPlayerCount: Object.keys(updatedPlayers).length,
            players: updatedPlayers,
          });
        } catch (error) {
          console.error("L·ªói reset game:", error);
          showMessage("L·ªói reset game.", true);
        } finally {
          showLoading(false);
        }
      }

      // --- H√ÄM RENDER (C·∫¨P NH·∫¨T GIAO DI·ªÜN) ---

      /**
       * H√†m render ch√≠nh, ƒëi·ªÅu ph·ªëi hi·ªÉn th·ªã
       * @param {object} roomData - D·ªØ li·ªáu t·ª´ Firestore
       */
      function renderGame(roomData) {
        if (!roomData) {
          leaveRoom();
          return;
        }

        // C·∫≠p nh·∫≠t th√¥ng tin chung
        isHost = roomData.hostId === userId;
        roomIdDisplay.textContent = roomData.roomId;
        roundDisplay.textContent = roomData.round;

        // C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i
        renderPlayerList(roomData);

        // ·∫®n t·∫•t c·∫£ c√°c state
        lobbyState.classList.add("hidden");
        playingState.classList.add("hidden");
        roundEndState.classList.add("hidden");
        gameEndState.classList.add("hidden");

        // X√≥a timer UI c≈©
        if (uiTimerInterval) clearInterval(uiTimerInterval);

        // Hi·ªÉn th·ªã state ph√π h·ª£p
        switch (roomData.gameState) {
          case "lobby":
            renderLobby(roomData);
            break;
          case "playing":
            renderPlaying(roomData);
            break;
          case "roundEnd":
            renderRoundEnd(roomData);
            break;
          case "gameEnd":
            renderGameEnd(roomData);
            break;
        }
      }

      /**
       * Render danh s√°ch ng∆∞·ªùi ch∆°i
       */
      function renderPlayerList(roomData) {
        playerList.innerHTML = ""; // X√≥a list c≈©
        const players = roomData.players;

        // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p kh√¥ng c√≥ ng∆∞·ªùi ch∆°i (v√≠ d·ª•: l·ªói)
        if (!players || Object.keys(players).length === 0) return;

        const myData = players[userId];

        // S·∫Øp x·∫øp: ng∆∞·ªùi ch∆°i hi·ªán t·∫°i l√™n ƒë·∫ßu, sau ƒë√≥ theo t√™n
        const sortedPlayerIds = Object.keys(players).sort((a, b) => {
          if (a === userId) return -1;
          if (b === userId) return 1;
          return players[a].name.localeCompare(players[b].name);
        });

        sortedPlayerIds.forEach((pid) => {
          const player = players[pid];
          const card = document.createElement("div");
          card.className =
            "player-card bg-gray-800 p-3 md:p-4 rounded-lg shadow-lg border-2 border-transparent transition-all duration-300";

          let readyIndicator = "";
          if (roomData.gameState === "lobby" && !player.isEliminated) {
            if (player.isReady) {
              readyIndicator =
                '<div class="w-full bg-green-500 h-2 rounded-full mt-2" title="S·∫µn s√†ng"></div>';
            } else {
              readyIndicator =
                '<div class="w-full bg-gray-600 h-2 rounded-full mt-2" title="Ch∆∞a s·∫µn s√†ng"></div>';
            }
          }

          let choiceDisplay = "?";
          if (player.isEliminated) {
            choiceDisplay = "B·ªä LO·∫†I";
          } else if (
            roomData.gameState === "playing" &&
            player.submittedThisRound
          ) {
            choiceDisplay = pid === userId ? player.currentChoice : "ƒê√É CH·ªåN";
          } else if (
            roomData.gameState === "roundEnd" ||
            roomData.gameState === "gameEnd"
          ) {
            choiceDisplay = player.currentChoice ?? "Kh√¥ng ch·ªçn";
          }

          // ƒê√°nh d·∫•u ch·ªß ph√≤ng
          const hostBadge =
            pid === roomData.hostId
              ? '<span class="text-xs text-yellow-400" title="Ch·ªß ph√≤ng">üëë</span>'
              : "";
          const myBadge =
            pid === userId
              ? '<span class="text-xs text-blue-400" title="B·∫°n">(B·∫°n)</span>'
              : "";

          card.innerHTML = `
                    <h3 class="text-base md:text-lg font-bold truncate">${
                      player.name
                    } ${hostBadge} ${myBadge}</h3>
                    <p class="text-xl md:text-2xl font-black ${getScoreColor(
                      player.score
                    )}">ƒêi·ªÉm: ${player.score}</p>
                    <p class="text-sm text-gray-400 mt-1">ƒê√£ ch·ªçn: <span class="font-bold text-base md:text-xl text-white">${choiceDisplay}</span></p>
                    ${readyIndicator}
                `;

          // Th√™m class ƒë·∫∑c bi·ªát
          if (player.isEliminated) {
            card.classList.add("eliminated");
          }
          if (
            roomData.gameState === "roundEnd" &&
            roomData.roundWinners.includes(pid)
          ) {
            card.classList.add("winner");
          }
          if (roomData.gameState === "roundEnd" && roomData.roundLosers[pid]) {
            card.classList.add("loser");
          }

          playerList.appendChild(card);
        });
      }

      function getScoreColor(score) {
        if (score > 5) return "text-green-400";
        if (score < 5 && score > 0) return "text-yellow-400";
        if (score <= 0) return "text-red-500";
        return "text-blue-400";
      }

      /**
       * Render tr·∫°ng th√°i Lobby
       */
      function renderLobby(roomData) {
        lobbyState.classList.remove("hidden");
        const myData = roomData.players[userId];
        if (myData) {
          readyBtn.disabled = false;
          if (myData.isReady) {
            readyBtn.textContent = "H·ªßy S·∫µn s√†ng";
            readyBtn.classList.remove("bg-green-600", "hover:bg-green-700");
            readyBtn.classList.add("bg-yellow-600", "hover:bg-yellow-700");
          } else {
            readyBtn.textContent = "S·∫µn s√†ng";
            readyBtn.classList.remove("bg-yellow-600", "hover:bg-yellow-700");
            readyBtn.classList.add("bg-green-600", "hover:bg-green-700");
          }
        }
      }

      /**
       * Render tr·∫°ng th√°i ƒêang ch∆°i
       */
      function renderPlaying(roomData) {
        playingState.classList.remove("hidden");
        playingRoundDisplay.textContent = roomData.round;

        const myData = roomData.players[userId];

        // N·∫øu b·ªã lo·∫°i, kh√¥ng cho ch∆°i
        if (!myData || myData.isEliminated) {
          document.getElementById("number-slider").disabled = true;
          submitNumberBtn.disabled = true;
          submitNumberBtn.classList.add("hidden");
          waitingForOthers.classList.remove("hidden");
          waitingForOthers.querySelector("p").textContent =
            "B·∫°n ƒë√£ b·ªã lo·∫°i. ƒêang ch·ªù k·∫øt qu·∫£...";
        }
        // N·∫øu ƒë√£ n·ªôp, ch·ªù
        else if (myData.submittedThisRound) {
          document.getElementById("number-slider").disabled = true;
          submitNumberBtn.disabled = true;
          submitNumberBtn.classList.add("hidden");
          waitingForOthers.classList.remove("hidden");
          waitingForOthers.querySelector(
            "p"
          ).textContent = `ƒê√£ ch·ªët s·ªë ${myData.currentChoice}! ƒêang ch·ªù ng∆∞·ªùi kh√°c...`;
        }
        // N·∫øu ch∆∞a n·ªôp, cho ch∆°i
        else {
          document.getElementById("number-slider").disabled = false;
          submitNumberBtn.disabled = false;
          submitNumberBtn.classList.remove("hidden");
          waitingForOthers.classList.add("hidden");
        }

        // C·∫≠p nh·∫≠t timer
        const deadline = roomData.roundDeadline.toDate();

        function updateTimer() {
          const remaining = Math.max(
            0,
            Math.floor((deadline.getTime() - Date.now()) / 1000)
          );
          timerDisplay.textContent = remaining;
          if (remaining <= 10) {
            timerDisplay.classList.add("text-red-600");
          } else {
            timerDisplay.classList.remove("text-red-600");
          }
          if (remaining === 0) {
            clearInterval(uiTimerInterval);
            // Kh√¥ng l√†m g√¨ th√™m, ch·ªù host t√≠nh to√°n
          }
        }

        updateTimer();
        uiTimerInterval = setInterval(updateTimer, 1000);
      }

      /**
       * Render tr·∫°ng th√°i K·∫øt th√∫c v√≤ng
       */
      function renderRoundEnd(roomData) {
        roundEndState.classList.remove("hidden");
        roundEndRoundDisplay.textContent = roomData.round;
        averageDisplay.textContent = roomData.roundAverage.toFixed(2);

        // Hi·ªÉn th·ªã ng∆∞·ªùi th·∫Øng/thua
        winnersList.innerHTML = "";
        if (roomData.roundWinners.length > 0) {
          roomData.roundWinners.forEach((pid) => {
            const player = roomData.players[pid];
            if (player) {
              const li = document.createElement("li");
              li.textContent = `${player.name} (Ch·ªçn: ${player.currentChoice})`;
              winnersList.appendChild(li);
            }
          });
        } else {
          winnersList.innerHTML = "<li>Kh√¥ng c√≥ ai th·∫Øng v√≤ng n√†y.</li>";
        }

        losersList.innerHTML = "";
        const loserIds = Object.keys(roomData.roundLosers);
        if (loserIds.length > 0) {
          loserIds.forEach((pid) => {
            const player = roomData.players[pid];
            const penalty = roomData.roundLosers[pid];
            if (player) {
              const li = document.createElement("li");
              li.textContent = `${player.name} (Ch·ªçn: ${player.currentChoice}) [${penalty} ƒëi·ªÉm]`;
              losersList.appendChild(li);
            }
          });
        } else {
          losersList.innerHTML = "<li>Kh√¥ng c√≥ ai b·ªã tr·ª´ ƒëi·ªÉm v√≤ng n√†y.</li>";
        }

        // Ch·ªâ ch·ªß ph√≤ng th·∫•y n√∫t "Next Round"
        if (isHost) {
          nextRoundBtn.classList.remove("hidden");
          waitingForHost.classList.add("hidden");
        } else {
          nextRoundBtn.classList.add("hidden");
          waitingForHost.classList.remove("hidden");
        }
      }

      /**
       * Render tr·∫°ng th√°i K·∫øt th√∫c game
       */
      function renderGameEnd(roomData) {
        gameEndState.classList.remove("hidden");
        rankings.innerHTML = "";

        const rankedPlayers = Object.values(roomData.players).sort(
          (a, b) => b.score - a.score
        );

        const medals = ["ü•á", "ü•à", "ü•â"];

        rankedPlayers.forEach((player, index) => {
          const rankItem = document.createElement("div");
          rankItem.className =
            "flex justify-between items-center bg-gray-700 p-4 rounded-lg text-lg";

          const rankText = medals[index]
            ? `${medals[index]} ${index + 1}. ${player.name}`
            : `${index + 1}. ${player.name}`;

          rankItem.innerHTML = `
                    <span class="font-bold ${
                      index < 3 ? "text-yellow-300" : ""
                    }">${rankText}</span>
                    <span class="font-bold">${player.score} ƒëi·ªÉm</span>
                `;
          rankings.appendChild(rankItem);
        });

        // Ch·ªâ ch·ªß ph√≤ng th·∫•y n√∫t "Reset"
        if (isHost) {
          resetGameBtn.classList.remove("hidden");
          waitingForReset.classList.add("hidden");
        } else {
          resetGameBtn.classList.add("hidden");
          waitingForReset.classList.remove("hidden");
        }
      }

      // Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu ph√≤ng m·ªõi nh·∫•t
      window.currentRoomData = null;

      // --- G·∫ÆN S·ª∞ KI·ªÜN ---

      window.onload = () => {
        initFirebase();

        // L·∫•y t√™n ƒë√£ l∆∞u
        playerNameInput.value = localStorage.getItem("playerName") || "";

        createRoomBtn.onclick = handleCreateRoom;
        joinRoomBtn.onclick = handleJoinRoom;
        readyBtn.onclick = handleReady;
        submitNumberBtn.onclick = handleSubmitNumber;

        // N√∫t ch·ªâ d√†nh cho host
        nextRoundBtn.onclick = () => {
          // S·ª≠ d·ª•ng d·ªØ li·ªáu ph√≤ng m·ªõi nh·∫•t t·ª´ snapshot
          if (isHost && window.currentRoomData) {
            startGame(window.currentRoomData);
          }
        };
        resetGameBtn.onclick = handleResetGame;

        // C·∫≠p nh·∫≠t gi√° tr·ªã thanh tr∆∞·ª£t
        numberSlider.oninput = (e) => {
          sliderValue.textContent = e.target.value;
        };

        // Copy Room ID
        roomIdDisplay.onclick = () => {
          if (currentRoomId) {
            // D√πng execCommand v√¨ clipboard.writeText c√≥ th·ªÉ b·ªã ch·∫∑n trong iframe
            const textArea = document.createElement("textarea");
            textArea.value = currentRoomId;
            textArea.style.position = "fixed"; // Tr√°nh cu·ªôn trang
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
              document.execCommand("copy");
              showMessage(`ƒê√£ copy Room ID: ${currentRoomId}`);
            } catch (err) {
              showMessage("Kh√¥ng th·ªÉ copy ID!", true);
            }
            document.body.removeChild(textArea);
          }
        };
      };
    </script>
  </body>
</html>
